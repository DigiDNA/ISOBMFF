/*
 *  Copyright (c) Meta Platforms, Inc. and its affiliates.
 */

#include <ISOBMFF.hpp>                  // for various
#include <BinaryDataStream.hpp> // for BinaryDataStream
#include <Parser.hpp>           // for Parser

#include <gmock/gmock.h>
#include <gtest/gtest.h>

namespace ISOBMFF {

class ISOBMFFSTSDTest : public ::testing::Test {
public:
  ISOBMFFSTSDTest() {}
  ~ISOBMFFSTSDTest() override {}
};

TEST_F(ISOBMFFSTSDTest, TestSTSDParser) {
  // fuzzer::conv: data
  const std::vector<uint8_t> &buffer = {
      // following example input is from a sample .mp4 video file
      // stsd size: 237 bytes
      // 0x00, 0x00, 0x00, 0xed,
      // stsd
      // 0x73, 0x74, 0x73, 0x64,
      // stsd content
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0xdd, 0x68, 0x76, 0x63, 0x31,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x06, 0xc0, 0x09, 0x00, 0x00, 0x48, 0x00, 0x00,
      0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x00, 0x18, 0xff, 0xff, 0x00, 0x00,
      0x00, 0x87, 0x68, 0x76, 0x63, 0x43, 0x01, 0x01,
      0x60, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x99, 0xf0, 0x00, 0xfc, 0xfd, 0xf8,
      0xf8, 0x00, 0x00, 0x03, 0x03, 0xa0, 0x00, 0x01,
      0x00, 0x20, 0x40, 0x01, 0x0c, 0x01, 0xff, 0xff,
      0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x00,
      0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x99, 0xac,
      0x0c, 0x07, 0xf2, 0x81, 0x54, 0xee, 0x6b, 0x28,
      0x01, 0x40, 0xa1, 0x00, 0x01, 0x00, 0x2e, 0x42,
      0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00,
      0xb0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
      0x99, 0xa0, 0x03, 0x60, 0x80, 0x09, 0x01, 0x65,
      0xae, 0xe4, 0xc9, 0x2e, 0xa6, 0xa1, 0x22, 0x41,
      0x20, 0x80, 0xfe, 0x50, 0x2a, 0x9d, 0xcd, 0x65,
      0x00, 0x17, 0x68, 0x50, 0x94, 0xa2, 0x00, 0x01,
      0x00, 0x0b, 0x44, 0x01, 0xc0, 0xe3, 0x0f, 0x09,
      0xc1, 0x50, 0xaf, 0xb0, 0x84
    };

  // fuzzer::conv: begin
  ISOBMFF::BinaryDataStream stream(buffer);
  ISOBMFF::Parser parser;
  std::shared_ptr<ISOBMFF::Box> box = parser.CreateBox("stsd");

  try {
    if (box != nullptr) {
      box->ReadData(parser, stream);
    }
  } catch (std::exception &e) {
    fprintf(stderr, "Caught exception: %s\n", e.what());
  }
  // fuzzer::conv: end

  // Validate STSD box
  auto stsd = std::dynamic_pointer_cast<ISOBMFF::STSD>(box);
  ASSERT_NE(stsd, nullptr) << "Failed to cast to STSD";
  // Validate sub-boxes inside STSD
  // Check version and flags
  EXPECT_EQ(stsd->GetVersion(), 0) << "Unexpected STSD version";
  EXPECT_EQ(stsd->GetFlags(), 0) << "Unexpected STSD flags";
  std::vector<std::shared_ptr<Box>> boxes = stsd->GetBoxes();
  ASSERT_EQ(boxes.size(), 1) << "Expected 1 sub-box, but found " << boxes.size();
  for (const auto &subbox : boxes) {
    const std::string type = subbox->GetName();
    if (type == "hvc1") {
      SUCCEED() << "Found expected hvc1 box";
    } else {
      FAIL() << "Unexpected sub-box type: " << type;
    }
  }
}
} // namespace ISOBMFF
